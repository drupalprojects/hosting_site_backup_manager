<?php
// $Id$

/**
 * Implementation of hook_menu
 */
function hosting_backup_queue_menu() {
  $items['admin/hosting/backup_queue'] = array(
    'title' => 'Backup schedule settings',
    'description' => 'Configure scheduled backups for hosted sites',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_backup_queue_settings'),
    'access arguments' => array('administer hosting backup queue'),
    'type' => MENU_LOCAL_TASK
  );
  return $items;
}

/**
 * Implementation of hook_perm
 */
function hosting_backup_queue_perm() {
  return array('create backup schedules', 'administer hosting backup queue');
}


/**
 * Configuration form for backup schedules
 */
function hosting_backup_queue_settings() {
  $form['hosting_backup_queue_default_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Backup sites by default'),
    '#description' => t('Sites without a specific backup schedule specified will get the settings here. These settings can be overriden by configuring specific sites.'),
    '#default_value' => variable_get('hosting_backup_queue_default_enabled', TRUE),
  );

  $intervals = drupal_map_assoc(array(
    strtotime('1 hour', 0),
    strtotime('6 hours', 0),
    strtotime('1 day', 0),
    strtotime('7 days', 0),
    strtotime('28 days', 0),
    strtotime('1 year', 0),
    ), 'format_interval');

  $form['hosting_backup_queue_default_interval'] = array(
    '#type' => 'select',
    '#title' => t('Default backup interval'),
    '#default_value' => variable_get('hosting_backup_queue_default_interval', strtotime('1 day', 0)),
    '#options' => $intervals,
  );
  return system_settings_form($form);
}

/**
 * Implementation of hook_hosting_queues
 *
 * Return a list of queues that this module needs to manage.
 */
function hosting_backup_queue_hosting_queues() {
  $queue['backup_queue'] = array(
    'name' => t('Backup queue'),
    'description' => t('Process the queue of backups.'),
    'type' => 'serial',  # run queue sequentially. always with the same parameters.
    'frequency' => strtotime("1 minute", 0),
    'items' => 2,
    'total_items' => 1,
    'singular' => t('backup'),
    'plural' => t('backups'),
    // TODO: Do we need to set this?
    'running_items' => 0,
  );
  return $queue;
}


/**
 * The main queue callback for the backups.
 */
function hosting_backup_queue_queue($count) {
  $sites = _hosting_backup_queue_get_outstanding_backups($count);
  foreach ($sites as $site_id => $site) {
    $site_alias = hosting_context_name($site_id);
    drush_backend_fork('hosting-task', array('@' . $site_alias, 'backup'));
  }
}

/**
 * Retrieve a list of sites to backup, now.
 *
 * @param limit
 *   The amount of items to return.
 * @return
 *   An associative array containing site nodes, indexed by node id.
 */
function _hosting_backup_queue_get_outstanding_backups($limit = 20) {
  $return = array();
  $interval = variable_get('hosting_backup_queue_default_interval', strtotime('1 day', 0));

  // TODO: Find a better way to do this than having three subselects.
  $subselect  = "(SELECT MAX(timestamp) FROM {hosting_site_backups} WHERE site = b.site)";
  $result = db_query_range("SELECT s.nid, $subselect AS last_backup_timestamp FROM {hosting_site} s INNER JOIN {node} n ON s.vid = n.vid LEFT JOIN {hosting_site_backups} b ON b.site = s.nid WHERE s.status = %d  AND (($subselect IS NULL) OR ($subselect < %d)) ORDER BY last_backup_timestamp, n.nid ASC", HOSTING_SITE_ENABLED, time() - $interval, 0, $limit);
  while ($node = db_fetch_object($result)) {
    $return[$node->nid] =  node_load($node->nid);
  }
  return $return;
}

/**
 * Return the number of sites to backup
 */
function hosting_backup_queue_sites_count() {
  if (variable_get('hosting_backup_queue_default_enabled', TRUE)) {
    // Just return the number of enabled sites.
    return db_result(db_query("SELECT COUNT(*) FROM {hosting_site} s INNER JOIN {node} n ON s.vid = n.vid WHERE s.status = %d", HOSTING_SITE_ENABLED));
  }
  else {
    // We don't support per site config, just yet.
    return 0;
  }
}
